//@version=5
strategy("RSI+Moving avg-Based Strategy with ATR TP/SL", overlay=false, default_qty_type=strategy.fixed, default_qty_value=25)
non_option_threshold_input = input.float(0.0, "Non option Gap Threshold (%)")
option_gap_threshold = input.float(3, "option Gap Threshold (%)")
gap_threshold = (syminfo.type == "option") ? option_gap_threshold : non_option_threshold_input


// === -------------------RSI Logic ---------------- ===
// == atr
atr_period = input.int(30, "ta period")
tp_atr_mult   = input.float(4.0, "TP ATR Multiple")
sl_atr_mult   = input.float(2.5, "SL ATR Multiple")

// === RSI Settings ===
rsi_tf        = input.timeframe("3", "RSI Timeframe")
rsi_len       = input.int(70, "RSI Length")
rsi_ma_len    = input.int(45, "RSI MA Length")
rsi_upper = 20
// === moving average Settings ===
ma_tf                   = input.timeframe("3", "MA Timeframe")
fast_ma_len = input.int(25, "Fast MA Length")
medium_ma_len = input.int(70, "Medium MA Length")
slow_ma_len = input.int(100, "Slow MA Length")



// === GAP COOLDOWN FUNCTION ===
gap_cooldown_passed() =>
    // GAP Thresholds based on instrument type
    float gap_pct_threshold_1 = ( (syminfo.type == "option"))? 7 : 0.5
    float gap_pct_threshold_2 = ( (syminfo.type == "option")) ? 14 : 1.0
    float gap_pct_threshold_3 = ( (syminfo.type == "option")) ? 21 : 1.5
    float gap_pct_threshold_4 = ( (syminfo.type == "option")) ? 28 : 2.0

    // Cooldown durations (in minutes)
    int cooldown_small    = 15
    int cooldown_med_1    = 30
    int cooldown_med_2    = 50
    int cooldown_large_1  = 60
    int cooldown_large_2  = 70

    // Market session timings
    int market_open_hour   = 9
    int market_open_minute = 15
    int trading_end_hour   = 11
    int trading_end_minute = 0

    // Gap calculation
    // Get daily series
    // Get daily values
    [daily_open_series, daily_close_series, daily_time_series] = request.security(syminfo.tickerid, "D", [open, close, time])

    // Detect start of new trading day
    is_new_day = ta.change(daily_time_series) != 0

    // Create persistent variables
    var float today_open = na
    var float prev_close = na

    // On new day, shift today’s open to open variable
    if is_new_day
        // ✅ Update today's open
        today_open := daily_open_series

        // ✅ Find previous working day's close
        for i = 1 to 10
            if not na(daily_close_series[i])
                prev_close := daily_close_series[i]
                break  // stop at first valid close

    // ✅ Calculate gap when both values are known
    gap_pct = not na(prev_close) and not na(today_open) ? 100 * (today_open - prev_close) / prev_close : na
    abs_gap = math.abs(gap_pct)

    // Time calculations
    cur_hour = hour(time)
    cur_minute = minute(time)
    cur_time_min = cur_hour * 60 + cur_minute
    market_open_min = market_open_hour * 60 + market_open_minute
    trading_end_min = trading_end_hour * 60 + trading_end_minute

    // Determine cooldown duration
    float cooling_duration = na
    if abs_gap > gap_threshold and abs_gap < gap_pct_threshold_1
        cooling_duration := cooldown_small
    else if abs_gap < gap_pct_threshold_2
        cooling_duration := cooldown_med_1
    else if abs_gap < gap_pct_threshold_3
        cooling_duration := cooldown_med_2
    else if abs_gap < gap_pct_threshold_4
        cooling_duration := cooldown_large_1
    else if abs_gap >= gap_pct_threshold_4
        cooling_duration := cooldown_large_2

    allowed_start = market_open_min + cooling_duration
    is_in_cooldown = cur_time_min >= market_open_min and cur_time_min < allowed_start and cur_time_min <= trading_end_min

    [is_in_cooldown, cooling_duration, gap_pct]

// === GAP COOLING PERIOD ===
[is_in_cooldown, cooling_duration, gap_pct] = gap_cooldown_passed()
abs_gap = math.abs(gap_pct)
is_new_day = dayofmonth != dayofmonth[1]

if is_new_day and abs_gap > gap_threshold
    label.new(bar_index,high + high * 0.002, syminfo.type + "\n" + "Daily Gap: " + str.tostring(gap_pct, "#.##") + "%\nCools for = " + str.tostring(cooling_duration, "#") + " min",style = label.style_label_left,yloc = gap_pct > 0 ? yloc.abovebar : yloc.belowbar,color =color.new(color.black, 96),textcolor = gap_pct > 0 ?  color.green: color.red,size = size.normal,force_overlay=true)



// -- rsi data prep
main_rsi      = request.security(syminfo.tickerid, rsi_tf, ta.rsi(close, rsi_len))
smooth_rsi    = ta.sma(main_rsi, rsi_ma_len)


// -- rsi signal
rsi_entry_signal = (main_rsi > smooth_rsi) and (main_rsi > rsi_upper)
rsi_exit_signal  = (main_rsi < smooth_rsi)

// === ------------Moving Average Trend Logic ------------===

// === moving average data prep ===
// Calculate SMA on current timeframe
[tf_price_data, momentum_ma, momentum_ma_slow, momentum_ma_long, atr, time_val] = request.security(syminfo.tickerid, ma_tf, [close,ta.sma(close, fast_ma_len),ta.sma(close, medium_ma_len),ta.sma(close, slow_ma_len), ta.atr(atr_period), time])


// === moving average signal ===
ma_entry_signal = (tf_price_data > momentum_ma_long) and (momentum_ma > momentum_ma_slow) and (momentum_ma_slow > momentum_ma_long)
ma_exit_signal  = (momentum_ma < momentum_ma_slow)

// === Combine Signals ===
buy_signal = ma_entry_signal and rsi_entry_signal and not is_in_cooldown
exit_signal = ma_exit_signal or rsi_exit_signal


// === other input
option_type = str.contains(syminfo.tickerid, "C") ? "CE" : "PE"
exit_hour     = input.int(14, "Exit Hour", minval=0, maxval=23)
exit_minute   = input.int(55, "Exit Minute", minval=0, maxval=59)
debug_mode    = input.bool(false, "Show Debug Info")


// === Time Logic ===
//time_tf = input.timeframe("5", "Trade execute Time Check -  TF")
//time_val = request.security(syminfo.tickerid, time_tf, time)
hour_tf = hour(time_val)
minute_tf = minute(time_val)
is_after_920  = (hour_tf > 9) or (hour_tf == 9 and minute_tf >= 20)
is_before_eod = (hour_tf < exit_hour) or (hour_tf == exit_hour and minute_tf < exit_minute)
within_trading_window = is_after_920 and is_before_eod

// === Enter/exit Trade Logic ===
can_enter = buy_signal and within_trading_window and strategy.opentrades == 0

var float entry_price = na
var float tp_price = na
var float sl_price = na

if can_enter and barstate.isconfirmed
    strategy.entry("Long", strategy.long, alert_message=option_type)
    // auto lowest TF close
    // entry_price := request.security(syminfo.tickerid, "1", close)
    entry_price := tf_price_data
    tp_price := entry_price + atr * tp_atr_mult
    sl_price := entry_price - atr * sl_atr_mult

exit_now = strategy.position_size > 0 and (exit_signal or not is_before_eod or tf_price_data >= tp_price or tf_price_data <= sl_price)

if exit_now and barstate.isconfirmed
    pnl_percent = (tf_price_data - entry_price) / entry_price * 100
    exit_reason = tf_price_data >= tp_price     ? "Take Profit" :
              tf_price_data <= sl_price     ? "Stop Loss" :
              exit_signal           ? "Exit" :
                                      "Day End"
    pnl_color = pnl_percent >= 0 ? color.green : color.red

    var exit_reason2 = ""
    if ma_exit_signal and rsi_exit_signal
        exit_reason2:= "both"
    else if rsi_exit_signal and not ma_exit_signal
        exit_reason2:= "RSI"
    else if not rsi_exit_signal and ma_exit_signal
        exit_reason2:= "MA"


    if not debug_mode
        label.new(bar_index, high * 1.5,
          "EXIT\n"+
          exit_reason + " " + exit_reason2 +
          "\nP&L: " + str.tostring(pnl_percent, "#.##") + "%" +
          "\nBuy: " + str.tostring(entry_price, format.mintick) +
          "\nSell: " + str.tostring(close, format.mintick),
          yloc=yloc.abovebar,
          style=label.style_label_up,
          size=size.normal,
          color=pnl_color,force_overlay=true)
    strategy.close("Long", alert_message="Exit " + exit_reason)
    entry_price := na
    tp_price := na
    sl_price := na

// But plot MAs using current chart timeframe for visual alignment
plot(ta.sma(close, fast_ma_len), color=color.green, title="Fast MA (local)",force_overlay=true)
plot(ta.sma(close, medium_ma_len), color=color.orange, title="Medium MA (local)", force_overlay=true)
plot(ta.sma(close, slow_ma_len), color=color.red, title="Slow MA (local)", force_overlay=true)
plot(main_rsi)
plot(smooth_rsi, color = color.green)
plot(50, color = color.black)
plot(70, color = color.red)
plot(30, color = color.green)
// === Debug Plots ===
plotshape(debug_mode and buy_signal, title="Buy Signal", location=location.belowbar, color=color.green, style=shape.triangleup, size=size.small, force_overlay=true)
plotshape(debug_mode and exit_signal, title="Exit Signal", location=location.abovebar, color=color.red, style=shape.triangledown, size=size.small, force_overlay=true)
